{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the Zeta2D Physics Engine! Zeta provides a simple solution for modeling 2D physics for anything you'd need. This page gives an overview of the organization of this engine and how to get started. For the purposes of this documentation assume a field is public unless otherwise specified.</p>"},{"location":"#organization","title":"Organization","text":"<p>The engine and documentation are split into sections by namespace with each namespace providing a select core functionality. There are 4 namespaces used throughout the engine:  </p> <ol> <li>ZMath: contains Zeta's custom math library, including many vital math utility functions.</li> <li>Primitives: contains all of the primitive shapes supported by Zeta and rigid and static bodies.</li> <li>Collisions: contains intersection detection, collision manifolds, and collision manifold calculators.</li> <li>Zeta: contains the physics handler used to model physics in your program.</li> </ol> <p>Zeta also makes use of preprocessor directives for certain constants and macros. If any of these are already defined, Zeta will fail to compile. Zeta defines the following keywords:</p> <ul> <li>PI (zmath2D.h)</li> <li>EPSILON (zmath2D.h)</li> <li>SIGNOF (zmath2D.h)</li> <li>TORADIANS (zmath2D.h)</li> <li>MIN (zmath2D.h)</li> <li>MAX (zmath2D.h)</li> <li>FPS_24 (physicshandler.h)</li> <li>FPS_30 (physicshandler.h)</li> <li>FPS_40 (physicshandler.h)</li> <li>FPS_50 (physicshandler.h)</li> <li>FPS_60 (physicshandler.h)</li> </ul> <p>If your graphics library defines any of these, go into the corresponding header file and surround it with an ifndef guard. For example: <pre><code>#ifndef PI\n#define PI 3.1415926535897932L\n#endif\n</code></pre></p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Here is a quick snippet to get Zeta2D up and running in your project. There are many more functions and classes than those used here. Information on those will be available throughout this documentation.</p> <pre><code>#include &lt;ZETA/physicshandler.h&gt;\nint main() {\n// Create your physics handler with the default settings.\n// Note: for this example, it is assumed the bottom left corner of the screen is the origin.\n//       However, Zeta will work regardless of coordinate system as long as you adjust the gravity.\nZeta::handler handler = Zeta::handler();\n// Create the colliders.\nPrimitives::Circle* c1 = new Primitives::Circle(ZMath::Vec2D(100.0f, 120.0f), 25.0f);\nPrimitives::Circle* c2 = new Primitives::Circle(ZMath::Vec2D(200.0f, 240.0f), 12.0f);\nPrimitives::AABB* aabb = new Primitives::AABB(ZMath::Vec2D(100.0f, 0.0f), ZMath::Vec2D(400.0f, 50.0f));\n// Create some rigid bodies to pass to the handler.\nPrimitives::RigidBody2D rb1(\nc1-&gt;c,                             // centerpoint\n50.0f,                             // mass\n0.9f,                              // coefficient of restitution\n0.975f,                            // linear damping\nPrimitives::RIGID_CIRCLE_COLLIDER, // collider type\nc1                                 // collider\n);\nPrimitives::RigidBody2D rb2(\nc2-&gt;c,                             // centerpoint\n20.0f,                             // mass\n0.95f,                             // coefficient of restitution\n0.8f,                              // linear damping\nPrimitives::RIGID_CIRCLE_COLLIDER, // collider type\nc2                                 // collider\n);\n// Create a static body to pass to the handler.\nPrimitives::StaticBody2D sb(\naabb-&gt;pos,                        // centerpoint\nPrimitives::STATIC_AABB_COLLIDER, // collider type\naabb                              // collider\n);\n// Add the rigid bodies to the handler.\nhandler.addRigidBody(&amp;rb1);\nhandler.addRigidBody(&amp;rb2);\n// Add the static body to the handler.\nhandler.addStaticBody(&amp;sb);\n// Program's dt loop.\nfloat dt = 0.0f;\n// Note: windowShouldNotClose should be replaced with the exit window condition in your graphics library.\nwhile (windowShouldNotClose) {\n/* Rendering/Drawing code should go here */\nhandler.update(dt); // The handler will subtract from dt for you.\n// Note: getEllapsedTime() should be replaced with the equivalent function in your graphics library.\ndt += getEllapsedTime(); }\nreturn 0;\n};\n</code></pre>"},{"location":"#contributing-and-bugs","title":"Contributing and Bugs","text":"<p>If you encounter a bug while using the engine, open it as an issue on Zeta's github page, and it will be fixed as soon as possible. If you wish to contribute to this physics engine, check out our contribution guidlines to learn more.</p>"},{"location":"collisions/","title":"Collisions","text":"<p>This section covers the Collisions namespace. Collisions contains functions relating to intersection detection and collision manifolds. Both intersections.h and collisions.h contain the code in the Collisions namespace.</p>"},{"location":"collisions/#structs","title":"Structs","text":"<p>This subsection touches on the structs included in Collisions. There is only only one struct in this namespace and details about it can be found below.</p>"},{"location":"collisions/#collision-manifold","title":"Collision Manifold","text":"<p>This struct stores data related to a collision. These are used by the physics handler for impulse resolution. It is not recommended for you to create and use your own collision manifolds; however, they are provided here on the offchance you need to. Note: this struct does not have any rule of 5 functions so the memory from the pointer in here must be managed by you if you do choose to make your own manifolds.</p>"},{"location":"collisions/#fields","title":"Fields","text":"Type Identifier Description bool hit Bool representing if there's a collision. If this is false, all of the other fields will be junk values. float pDist The penetration distance of the collision. Vec2D normal The collision normal. Vec2D* contactPoints The point(s) at which the colliders overlap. int numPoints The number of contact points."},{"location":"collisions/#functions","title":"Functions","text":"<p>This subsection showcases the many functions in this namespace. A majority of the Collisions namespace is comprised of intersection detection functions and details on those are provided here.</p>"},{"location":"collisions/#pointandline","title":"PointAndLine","text":"<p>Function Signature:</p> <pre><code>bool PointAndLine(ZMath::Vec2D const &amp;point, Primitives::Line2D const &amp;line);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a point lies on a line.</li> </ul> <p>Parameters:</p> <ul> <li>point (Vec2D) - A point in 2D space.</li> <li>line (Line2D) - A line in 2D space.</li> </ul>"},{"location":"collisions/#pointandcircle","title":"PointAndCircle","text":"<p>Function Signature:</p> <pre><code>bool PointAndCircle(ZMath::Vec2D const &amp;point, Primitives::Circle const &amp;circle);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a point lies in a circle.</li> </ul> <p>Parameters:</p> <ul> <li>point (Vec2D) - A point in 2D space.</li> <li>circle (Circle) - A circle.</li> </ul>"},{"location":"collisions/#pointandaabb","title":"PointAndAABB","text":"<p>Function Signature:</p> <pre><code>bool PointAndAABB(ZMath::Vec2D const &amp;point, Primitives::AABB const &amp;aabb);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a point lies in an AABB.</li> </ul> <p>Parameters:</p> <ul> <li>point (Vec2D) - A point in 2D space.</li> <li>aabb (AABB) - An unrotated rectangle.</li> </ul>"},{"location":"collisions/#pointandbox2d","title":"PointAndBox2D","text":"<p>Function Signature:</p> <pre><code>bool PointAndBox2D(ZMath::Vec2D const &amp;point, Primitives::Box2D const &amp;box);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a point lies in a Box2D.</li> </ul> <p>Parameters:</p> <ul> <li>point (Vec2D) - A point in 2D space.</li> <li>box (Box2D) - A rotated rectangle.</li> </ul>"},{"location":"collisions/#lineandpoint","title":"LineAndPoint","text":"<p>Function Signature:</p> <pre><code>bool LineAndPoint(Primitives::Line2D const &amp;line, ZMath::Vec2D const &amp;point);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a point lies on a line.</li> </ul> <p>Parameters:</p> <ul> <li>line (Line2D) - A line in 2D space.</li> <li>point (Vec2D) - A point in 2D space.</li> </ul>"},{"location":"collisions/#lineandline","title":"LineAndLine","text":"<p>Function Signature:</p> <pre><code>bool LineAndLine(Primitives::Line2D const &amp;line1, Primitives::Line2D const &amp;line2);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if two line segments intersect.</li> </ul> <p>Parameters:</p> <ul> <li>line1 (Line2D) - A line in 2D space.</li> <li>line2 (Line2D) - A second line in 2D space.</li> </ul>"},{"location":"collisions/#lineandcircle","title":"LineAndCircle","text":"<p>Function Signature:</p> <pre><code>bool LineAndCircle(Primitives::Line2D const &amp;line, Primitives::Circle const &amp;circle);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a line intersects a circle.</li> </ul> <p>Parameters:</p> <ul> <li>line (Line2D) - A line in 2D space.</li> <li>circle (Circle) - A circle.</li> </ul>"},{"location":"collisions/#lineandaabb","title":"LineAndAABB","text":"<p>Function Signature:</p> <pre><code>bool LineAndAABB(Primitives::Line2D const &amp;line, Primitives::AABB const &amp;aabb);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a line intersects an AABB.</li> </ul> <p>Parameters:</p> <ul> <li>line (Line2D) - A line in 2D space.</li> <li>aabb (AABB) - An unrotated rectangle.</li> </ul>"},{"location":"collisions/#lineandbox2d","title":"LineAndBox2D","text":"<p>Function Signature:</p> <pre><code>bool LineAndBox2D(Primitives::Line2D const &amp;line, Primitives::Box2D const &amp;box);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a line intersects a Box2D.</li> </ul> <p>Parameters:</p> <ul> <li>point (Line2D) - A line in 2D space.</li> <li>box (Box2D) - A rotated rectangle.</li> </ul>"},{"location":"collisions/#raycast","title":"raycast","text":"<p>Function Signature:</p> <pre><code>bool raycast(Primitives::Ray2D const &amp;ray, Primitives::Circle const &amp;circle, float &amp;dist);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a ray intersects a circle and determine the distance to the point of intersection.</li> </ul> <p>Parameters:</p> <ul> <li>ray (Ray2D) - A ray in 2D space.</li> <li>circle (Circle) - A circle.</li> <li>dist (float) - A float updated to be the distance to the point of intersection. If this returns false, this will be a junk value.</li> </ul> <p>Function Signature:</p> <pre><code>bool raycast(Primitives::Ray2D const &amp;ray, Primitives::AABB const &amp;aabb, float &amp;dist);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a ray intersects an AABB and determine the distance to the point of intersection..</li> </ul> <p>Parameters:</p> <ul> <li>ray (Ray2D) - A ray in 2D space.</li> <li>aabb (AABB) - An unrotated rectangle.</li> <li>dist (float) - A float updated to be the distance to the point of intersection. If this returns false, this will be a junk value.</li> </ul> <p>Function Signature:</p> <pre><code>bool raycast(Primitives::Ray2D const &amp;ray, Primitives::Box2D const &amp;box, float &amp;dist);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a ray intersects a Box2D and determine the distance to the point of intersection.</li> </ul> <p>Parameters:</p> <ul> <li>ray (Ray2D) - A ray in 2D space.</li> <li>box (Box2D) - A rotated rectangle.</li> <li>dist (float) - A float updated to be the distance to the point of intersection. If this returns false, this will be a junk value.</li> </ul>"},{"location":"collisions/#circleandpoint","title":"CircleAndPoint","text":"<p>Function Signature:</p> <pre><code>bool CircleAndPoint(Primitives::Circle const &amp;circle, ZMath::Vec2D const &amp;point);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a point lies in a circle.</li> </ul> <p>Parameters:</p> <ul> <li>circle (Circle) - A circle.</li> <li>point (Vec2D) - A point in 2D space.</li> </ul>"},{"location":"collisions/#circleandline","title":"CircleAndLine","text":"<p>Function Signature:</p> <pre><code>bool CircleAndLine(Primitives::Circle const &amp;circle, Primitives::Line2D const &amp;line);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a line intersects a circle.</li> </ul> <p>Parameters:</p> <ul> <li>circle (Circle) - A circle.</li> <li>line (Vec2D) - A line in 2D space.</li> </ul>"},{"location":"collisions/#circleandcircle","title":"CircleAndCircle","text":"<p>` Function Signature:</p> <pre><code>bool CircleAndCircle(Primitives::Circle const &amp;circle1, Primitives::Circle const &amp;circle2);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if two circles intersect.</li> </ul> <p>Parameters:</p> <ul> <li>circle1 (Circle) - A circle.</li> <li>circle2 (Circle) - A second circle.</li> </ul> <p>Function Signature:</p> <pre><code>bool CircleAndCircle(Primitives::Circle const &amp;circle1, Primitives::Circle const &amp;circle2, ZMath::Vec2D &amp;normal);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if two circles intersect and calculate the collision normal.</li> </ul> <p>Parameters:</p> <ul> <li>circle1 (Circle) - A circle.</li> <li>circle2 (Circle) - A second circle.</li> <li>normal (Vec2D) - Updated to be the collision normal. If this returns false, this will be a junk value.</li> </ul>"},{"location":"collisions/#circleandaabb","title":"CircleAndAABB","text":"<p>Function Signature:</p> <pre><code>bool CircleAndAABB(Primitives::Circle const &amp;circle, Primitives::AABB const &amp;aabb);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a circle intersects an AABB.</li> </ul> <p>Parameters:</p> <ul> <li>circle (Circle) - A circle.</li> <li>aabb (AABB) - An unrotated rectangle.</li> </ul> <p>Function Signature:</p> <pre><code>bool CircleAndAABB(Primitives::Circle const &amp;circle, Primitives::AABB const &amp;aabb, ZMath::Vec2D &amp;normal);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a circle intersects an AABB and calculate the collision normal.</li> </ul> <p>Parameters:</p> <ul> <li>circle (Circle) - A circle.</li> <li>aabb (AABB) - An unrotated rectangle.</li> <li>normal (Vec2D) - Updated to be the collision normal. If this returns false, this will be a junk value.</li> </ul>"},{"location":"collisions/#circleandbox2d","title":"CircleAndBox2D","text":"<p>Function Signature:</p> <pre><code>bool CircleAndBox2D(Primitives::Circle const &amp;circle, Primitives::Box2D const &amp;box);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a circle intersects a Box2D.</li> </ul> <p>Parameters:</p> <ul> <li>circle (Circle) - A circle.</li> <li>box (Box2D) - A rotated rectangle.</li> </ul> <p>Function Signature:</p> <pre><code>bool CircleAndBox2D(Primitives::Circle const &amp;circle, Primitives::Box2D const &amp;box, ZMath::Vec2D &amp;normal);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a circle intersects a Box2D and calculate the collision normal.</li> </ul> <p>Parameters:</p> <ul> <li>circle (Circle) - A circle.</li> <li>box (Box2D) - A rotated rectangle.</li> <li>normal (Vec2D) - Updated to be the collision normal. If this returns false, this will be a junk value.</li> </ul>"},{"location":"collisions/#aabbandpoint","title":"AABBAndPoint","text":"<p>Function Signature:</p> <pre><code>bool AABBAndPoint(Primitives::AABB const &amp;aabb, ZMath::Vec2D const &amp;point);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a point lies in an AABB.</li> </ul> <p>Parameters:</p> <ul> <li>aabb (AABB) - An unrotated rectangle.</li> <li>point (Vec2D) - A point in 2D space.</li> </ul>"},{"location":"collisions/#aabbandline","title":"AABBAndLine","text":"<p>Function Signature:</p> <pre><code>bool AABBAndLine(Primitives::AABB const &amp;aabb, Primitives::Line2D const &amp;line);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a line intersects an AABB.</li> </ul> <p>Parameters:</p> <ul> <li>aabb (AABB) - An unrotated rectangle</li> <li>line (Line2D) - A line in 2D space.</li> </ul>"},{"location":"collisions/#aabbandcircle","title":"AABBAndCircle","text":"<p>Function Signature:</p> <pre><code>bool AABBAndCircle(Primitives::AABB const &amp;aabb, Primitives::Circle const &amp;circle);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a circle intersects an AABB.</li> </ul> <p>Parameters:</p> <ul> <li>aabb (AABB) - An unrotated rectangle.</li> <li>circle (Circle) - A circle.</li> </ul> <p>Function Signature:</p> <pre><code>bool AABBAndCircle(Primitives::AABB const &amp;aabb, Primitives::Circle const &amp;circle, ZMath::Vec2D &amp;normal);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a circle intersects an AABB and calculate the collision normal.</li> </ul> <p>Parameters:</p> <ul> <li>aabb (AABB) - An unrotated rectangle.</li> <li>circle (Circle) - A circle.</li> <li>normal (Vec2D) - Updated to be the collision normal. If this returns false, this will be a junk value.</li> </ul>"},{"location":"collisions/#aabbandaabb","title":"AABBAndAABB","text":"<p>Function Signature:</p> <pre><code>bool AABBAndAABB(Primitives::AABB const &amp;aabb1, Primitives::AABB const &amp;aabb2);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if two AABBs intersect.</li> </ul> <p>Parameters:</p> <ul> <li>aabb1 (AABB) - An unrotated rectangle.</li> <li>aabb2 (AABB) - A second unrotated rectangle.</li> </ul> <p>Function Signature:</p> <pre><code>bool AABBAndAABB(Primitives::AABB const &amp;aabb1, Primitives::AABB const &amp;aabb2, ZMath::Vec2D &amp;normal);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if two AABBs intersect and calculate the collision normal.</li> </ul> <p>Parameters:</p> <ul> <li>aabb1 (AABB) - An unrotated rectangle.</li> <li>aabb2 (AABB) - A second unrotated rectangle.</li> <li>normal (Vec2D) - Updated to be the collision normal. If this returns false, this will be a junk value.</li> </ul>"},{"location":"collisions/#aabbandbox2d","title":"AABBAndBox2D","text":"<p>Function Signature:</p> <pre><code>bool AABBAndBox2D(Primitives::AABB const &amp;aabb, Primitives::Box2D const &amp;box);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if an AABB and Box2D intersect.</li> </ul> <p>Parameters:</p> <ul> <li>aabb (AABB) - An unrotated rectangle.</li> <li>box (Box2D) - A rotated rectangle.</li> </ul> <p>Function Signature:</p> <pre><code>bool AABBAndBox2D(Primitives::AABB const &amp;aabb, Primitives::Box2D const &amp;box, ZMath::Vec2D &amp;normal);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if an AABB and Box2D intersect and calculate the collision normal.</li> </ul> <p>Parameters:</p> <ul> <li>aabb (AABB) - An unrotated rectangle.</li> <li>box (Box2D) - A rotated rectangle.</li> <li>normal (Vec2D) - Updated to be the collision normal. If this returns false, this will be a junk value.</li> </ul>"},{"location":"collisions/#box2dandpoint","title":"Box2DAndPoint","text":"<p>Function Signature:</p> <pre><code>bool Box2DAndPoint(Primitives::Box2D const &amp;box, ZMath::Vec2D const &amp;point);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a point lies in a Box2D.</li> </ul> <p>Parameters:</p> <ul> <li>box (Box2D) - A rotated rectangle.</li> <li>point (Vec2D) - A point in 2D space.</li> </ul>"},{"location":"collisions/#box2dandline","title":"Box2DAndLine","text":"<p>Function Signature:</p> <pre><code>bool Box2DAndLine(Primitives::Box2D const &amp;box, Primitives::Line2D const &amp;line);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a line intersects a Box2D.</li> </ul> <p>Parameters:</p> <ul> <li>box (Box2D) - A rotated rectangle.</li> <li>line (Line2D) - A line in 2D space.</li> </ul>"},{"location":"collisions/#box2dandcircle","title":"Box2DAndCircle","text":"<p>Function Signature:</p> <pre><code>bool Box2DAndCircle(Primitives::Box2D const &amp;box, Primitives::Circle const &amp;circle);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a circle intersects a Box2D.</li> </ul> <p>Parameters:</p> <ul> <li>box (Box2D) - A rotated rectangle.</li> <li>circle (Circle) - A circle.</li> </ul> <p>Function Signature:</p> <pre><code>bool Box2DAndCircle(Primitives::Box2D const &amp;box, Primitives::Circle const &amp;circle, ZMath::Vec2D &amp;normal);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if a circle intersects a Box2D and calculate the collision normal.</li> </ul> <p>Parameters:</p> <ul> <li>box (Box2D) - A rotated rectangle.</li> <li>circle (Circle) - A circle.</li> <li>normal (Vec2D) - Updated to be the collision normal. If this returns false, this will be a junk value.</li> </ul>"},{"location":"collisions/#box2dandaabb","title":"Box2DAndAABB","text":"<p>Function Signature:</p> <pre><code>bool Box2DAndAABB(Primitives::Box2D const &amp;box, Primitives::AABB const &amp;aabb);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if an AABB intersects a Box2D.</li> </ul> <p>Parameters:</p> <ul> <li>box (Box2D) - A rotated rectangle.</li> <li>aabb (AABB) - An unrotated rectangle.</li> </ul> <p>Function Signature:</p> <pre><code>bool Box2DAndAABB(Primitives::Box2D const &amp;box, Primitives::AABB const &amp;aabb, ZMath::Vec2D &amp;normal);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if an AABB intersects a Box2D and calculate the collision normal.</li> </ul> <p>Parameters:</p> <ul> <li>box (Box2D) - A rotated rectangle.</li> <li>aabb (AABB) - An unrotated rectangle.</li> <li>normal (Vec2D) - Updated to be the collision normal. If this returns false, this will be a junk value.</li> </ul>"},{"location":"collisions/#box2dandbox2d","title":"Box2DAndBox2D","text":"<p>Function Signature:</p> <pre><code>bool Box2DAndBox2D(Primitives::Box2D const &amp;box1, Primitives::Box2D const &amp;box2);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if two Box2Ds intersect.</li> </ul> <p>Parameters:</p> <ul> <li>box1 (Box2D) - A rotated rectangle.</li> <li>box2 (Box2D) - A second rotated rectangle.</li> </ul> <p>Function Signature:</p> <pre><code>bool Box2DAndBox2D(Primitives::Box2D const &amp;box1, Primitives::Box2D const &amp;box2, ZMath::Vec2D &amp;normal);\n</code></pre> <p>Description: </p> <ul> <li>Return a bool representing if two Box2Ds intersect and calculate the collision normal.</li> </ul> <p>Parameters:</p> <ul> <li>box1 (Box2D) - A rotated rectangle.</li> <li>box2 (Box2D) - A second rotated rectangle.</li> <li>normal (Vec2D) - Updated to be the collision normal. If this returns false, this will be a junk value.</li> </ul>"},{"location":"collisions/#findcollisionfeatures","title":"findCollisionFeatures","text":"<p>Function Signature:</p> <pre><code>CollisionManifold findCollisionFeatures(Primitives::RigidBody2D* rb1, Primitives::RigidBody2D* rb2);\n</code></pre> <p>Description: </p> <ul> <li>Return a CollisionManifold with data about the collision between two rigid bodies. The physics handler calls this automatically. It is not recommended for you to call this function.</li> </ul> <p>Parameters:</p> <ul> <li>rb1 (RigidBody2D*) - A pointer to a rigid body.</li> <li>rb2 (RigidBody2D*) - A pointer to a different rigid body.</li> </ul>"},{"location":"collisions/#findcollisionfeatures_1","title":"findCollisionFeatures","text":"<p>Function Signature:</p> <pre><code>CollisionManifold findCollisionFeatures(Primitives::RigidBody2D* rb, Primitives::StaticBody2D* sb);\n</code></pre> <p>Description: </p> <ul> <li>Return a CollisionManifold with data about the collision between a rigid and static body. The physics handler calls this automatically. It is not recommended for you to call this function.</li> </ul> <p>Parameters:</p> <ul> <li>rb (RigidBody2D*) - A pointer to a rigid body.</li> <li>sb (StaticBody2D*) - A pointer to a static body.</li> </ul>"},{"location":"primitives/","title":"Primitives","text":"<p>This section covers the Primitives namespace. Primitives contains all of the basic shapes defined in Zeta and rigid and static bodies. Both primitives.h and bodies.h contain code in the Primitives namespace.</p>"},{"location":"primitives/#classes","title":"Classes","text":"<p>This subsection touches on the classes found in the Primitives namespace. Each of these classes represent a different simple shape that will be recognized for the engine. The ones that can be used as a collider will be marked as such.</p>"},{"location":"primitives/#ray2d","title":"Ray2D","text":"<p>This class models a 2D ray. Rays are most notably used to simulate light, but can also be used to model the path an object is taking. Ray2D does not contain any functions or operators. Below are the fields and the constructor for Ray2D.</p>"},{"location":"primitives/#fields","title":"Fields","text":"Type Identifier Description Vec2D origin The ray's origin point. Vec2D dir The ray's direction as a normalized vector."},{"location":"primitives/#constructor","title":"Constructor","text":"<p>Description: </p> <ul> <li>Create a 2D ray from an origin point and normalized direction vector.  </li> </ul> <p>Parameters:</p> <ul> <li>origin (Vec2D) - the ray's origin point</li> <li>dir (Vec2D) - the ray's normalized direction vector  </li> </ul> <pre><code>Ray2D(ZMath::Vec2D const &amp;origin, ZMath::Vec2D const &amp;dir);\n</code></pre>"},{"location":"primitives/#line2d","title":"Line2D","text":"<p>This class models a 2D line segment, which will be referred to as a \"line\" for convenience. Lines are not commonly used for physics, but it is included in case you need one for a niche purpose. Below are the fields, constructor, and functions comprising the class.</p>"},{"location":"primitives/#fields_1","title":"Fields","text":"Type Identifier Description Vec2D start The line's starting point. Vec2D end The line's ending point."},{"location":"primitives/#constructor_1","title":"Constructor","text":"<p>Description: </p> <ul> <li>Create a 2D line from a starting and ending point.  </li> </ul> <p>Parameters:</p> <ul> <li>start (Vec2D) - the line's starting point</li> <li>end (Vec2D) - the line's ending point</li> </ul> <pre><code>Line2D(ZMath::Vec2D const &amp;start, ZMath::Vec2D const &amp;end);\n</code></pre>"},{"location":"primitives/#functions","title":"Functions","text":"<pre><code>ZMath::Vec2D getMin() const; // Returns the lowest value of x and y the line reaches.\nZMath::Vec2D getMax() const; // Returns the greatest value of x and y the line reaches.\n</code></pre>"},{"location":"primitives/#circle","title":"Circle","text":"<p>This class models a circle. Circles are a common choice for colliders, especially to model balls, projectiles, and sometimes even players and enemies. This class does not contain any functions. Below are the fields and constructor.</p>"},{"location":"primitives/#fields_2","title":"Fields","text":"Type Identifier Description Vec2D c The circle's centerpoint. float r The circle's radius."},{"location":"primitives/#constructor_2","title":"Constructor","text":"<p>Description: </p> <ul> <li>Create a circle from a centerpoint and a radius.  </li> </ul> <p>Parameters:</p> <ul> <li>c (Vec2D) - the circle's centerpoint</li> <li>r (float) - the circle's radius</li> </ul> <pre><code>Circle(ZMath::Vec2D const &amp;c, float r);\n</code></pre>"},{"location":"primitives/#aabb","title":"AABB","text":"<p>This class models an unrotated rectangle. This is used over a Box2D for the unrotated case as it allows for less computationally expensive functions to be ran. AABBs are a common choice for colliders, especially for walls and box-like entities. Below are the fields, constructor, and functions.</p>"},{"location":"primitives/#fields_3","title":"Fields","text":"Type Identifier Description Vec2D pos The AABB's centerpoint. private Vec2D halfsize Half the dimensions of the AABB."},{"location":"primitives/#constructor_3","title":"Constructor","text":"<p>Description: </p> <ul> <li>Create an AABB from a min vertex and a max vertex.  </li> </ul> <p>Parameters:</p> <ul> <li>min (Vec2D) - the AABB's vertex with the lowest values of x and y contained in the AABB (known as the min vertex)</li> <li>max (Vec2D) - the AABB's vertex with the greatest values of x and y contained in the AABB (known as the max vertex)</li> </ul> <pre><code>AABB(ZMath::Vec2D const &amp;min, ZMath::Vec2D const &amp;max);\n</code></pre>"},{"location":"primitives/#functions_1","title":"Functions","text":"<pre><code>ZMath::Vec2D getMin() const;       // Returns the AABB's min vertex.\nZMath::Vec2D getMax() const;       // Returns the AABB's max vertex.\nZMath::Vec2D getHalfsize() const;  // Returns the AABB's halfsize.\nZMath::Vec2D* getVertices() const; // Returns a pointer array of size 4 with the vertices of the AABB.\n</code></pre>"},{"location":"primitives/#box2d","title":"Box2D","text":"<p>This class models a rotated rectangle. This should only be used for non-zero cases of rotation as it is more computationally expensive to conduct Box2D collision checks than AABB checks. Box2Ds are a common choice for colliders, especially for non-aligned walls or box-like entities. Below are the fields, functions, and constructor.</p>"},{"location":"primitives/#fields_4","title":"Fields","text":"Type Identifier Description Vec2D pos The Box2D's centerpoint. Mat2D rot The Box2D's rotation matrix. This will rotate anything from the Box2D's local space to global space. float theta The angle the Box2D is rotated by in degrees. private Vec2D halfsize Half the dimensions of the Box2D."},{"location":"primitives/#constructor_4","title":"Constructor","text":"<p>Description: </p> <ul> <li>Create a Box2D from a min vertex, a max vertex, and an angle in degrees.  </li> </ul> <p>Parameters:</p> <ul> <li>min (Vec2D) - the Box2D's vertex with the lowest values of x and y contained in the Box2D if it was not rotated (known as the min vertex)</li> <li>max (Vec2D) - the Box2D's vertex with the greatest values of x and y contained in the Box2D if it was not rotated (known as the max vertex)</li> <li>theta (float) - the angle the Box2D is rotated by in degrees.</li> </ul> <pre><code>Box2D(ZMath::Vec2D const &amp;min, ZMath::Vec2D const &amp;max, float theta);\n</code></pre>"},{"location":"primitives/#functions_2","title":"Functions","text":"<pre><code>ZMath::Vec2D getLocalMin() const;  // Returns the Box2D's min vertex in the Box2D's local space.\nZMath::Vec2D getLocalMax() const;  // Returns the Box2D's max vertex in the Box2D's local space.\nZMath::Vec2D getHalfsize() const;  // Returns the Box2D's halfsize.\nZMath::Vec2D* getVertices() const; // Returns a pointer array of size 4 with the vertices of the Box2D in global space.\n</code></pre>"},{"location":"primitives/#rigidbody2d","title":"RigidBody2D","text":"<p>This class models a 2D rigid body. A rigid body is an object that's affected by physics. It has various fields storing information to use for physics updates. Below are the core fields and functions.</p>"},{"location":"primitives/#fields_5","title":"Fields","text":"Type Identifier Description Vec2D pos The rigid body's centerpoint. Vec2D vel The rigid body's velocity. It is initialized to the 0 vector by default. Vec2D netForce The rigid body's net force. It is initialized to the 0 vector by default. float mass The mass of the rigid body in grams. float invMass 1 over the mass of the rigid body in grams. float cor The coefficient of restitution of the rigid body.This represents a loss of kinetic energy dueto heat and should be between 0 and 1. 1 is perfectly elastic and 0 is perfectly inelastic. float linearDamping Controls how much the rigid body resists translation and should be on the interval (0, 1].1 = no resistance to translation. RigidBodyCollider colliderType The collider type attached to the rigid body. Union collider A union containing a circle, AABB, and Box2D referenced by .circle, .aabb, and .box respectively.Only use the collider associated with the collider type attached. You must manually assign thisand assigning the wrong collider will break the physics engine."},{"location":"primitives/#constructors","title":"Constructors","text":"<p>Description: </p> <ul> <li>Create a 2D rigid body from a position, mass, coefficient of restitution, linear damping value, colliderType, and a collider.</li> </ul> <p>Parameters:</p> <ul> <li>pos (Vec2D) - The centerpoint of the rigid body. This should be equal to the centerpoint of the collider.</li> <li>mass (float) - The mass of the rigid body in grams.</li> <li>cor (float) - The coefficient of restitution of the rigid body. Should be between 0 and 1 inclusive.</li> <li>linearDamping (float) - The linear damping of the rigid body. Should be on the interval (0, 1].</li> <li>colliderType (RigidBodyCollider) - Enum value informing the engine which type of collider is attached to the rigid body.</li> <li>collider (void*) - Pointer to the collider of the rigid body. If this does not match the collider type specified, undefined behavior will occur. If you specify the RIGID_NONE collider type, you should set this to nullptr. Delete will not be called on this pointer.</li> </ul> <pre><code>RigidBody2D(\nZMath::Vec2D const &amp;pos,\nfloat mass,\nfloat cor,\nfloat linearDamping, RigidBodyCollider colliderType,\nvoid* collider\n);\n</code></pre> <p>RigidBody2D also offers a default constructor that does nothing. If you use the default constructor, you must manually assign every field or the rigid body will cause undefined behavior.</p>"},{"location":"primitives/#functions_3","title":"Functions","text":"<p>Function Signature:</p> <pre><code>void update(ZMath::Vec2D const &amp;g, float dt);\n</code></pre> <p>Description: </p> <ul> <li>Updates the rigid body based on its current physics attributes. The physics handler will run this for it so it is not recommended to call this.</li> </ul> <p>Parameters:</p> <ul> <li>g (Vec2D) - The acceleration due to gravity.</li> <li>dt (float) - Amount of time passed since the last update.</li> </ul>"},{"location":"primitives/#staticbody2d","title":"StaticBody2D","text":"<p>This class models a 2D static body. A static body is an object unaffected by physics. Static bodies are commonly used to model walls, goals, death zones, etc. as those objects should be unaffected by physics. Static bodies still contain a collider, allowing you to check and resolve static body collisions how you see fit. Below are the core fields.</p>"},{"location":"primitives/#fields_6","title":"Fields","text":"Type Identifier Description Vec2D pos The static body's centerpoint. StaticBodyCollider colliderType The collider type attached to the static body. Union collider A union containing a circle, AABB, and Box2D referenced by .circle, .aabb, and .box respectively.Only use the collider associated with the collider type attached."},{"location":"primitives/#constructors_1","title":"Constructors","text":"<p>Description: </p> <ul> <li>Create a 2D static body from a position, colliderType, and collider.</li> </ul> <p>Parameters:</p> <ul> <li>pos (Vec2D) - The centerpoint of the static body. This should be equal to the centerpoint of the collider.</li> <li>colliderType (StaticBodyCollider) - Enum value informing the engine which type of collider is attached to the static body.</li> <li>collider (void*) - Pointer to the collider of the static body. If this does not match the collider type specified, undefined behavior will occur. If you specify the STATIC_NONE collider type, you should set this to nullptr. Delete will not be called on this pointer.</li> </ul> <pre><code>StaticBody2D(ZMath::Vec2D const &amp;pos, StaticBodyCollider colliderType, void* collider);\n</code></pre> <p>StaticBody2D also offers a default constructor that does nothing. If you use the default constructor, you must manually assign every field or the static body will cause undefined behavior.</p>"},{"location":"primitives/#enums","title":"Enums","text":"<p>The primitives namespace has two enums. Both are used to specify the collider types for rigid and static bodies.</p>"},{"location":"primitives/#rigidbodycollider","title":"RigidBodyCollider","text":"<p>This enum is used to indicate the type of collider attached to a rigid body.</p> Identifier Description RIGID_CIRCLE_COLLIDER Indicates a circle collider is attached to the rigid body. RIGID_AABB_COLLIDER Indicates an AABB collider is attached to the rigid body. RIGID_BOX2D_COLLIDER Indicates a Box2D collider is attached to the rigid body. RIGID_CUSTOM_COLLIDER Indicates a custom collider is attached to the rigid body. RIGID_NONE Indicates no collider is attached to the rigid body."},{"location":"primitives/#staticbodycollider","title":"StaticBodyCollider","text":"<p>This enum is used to indicate the type of collider attached to a static body.</p> Identifier Description STATIC_CIRCLE_COLLIDER Indicates a circle collider is attached to the static body. STATIC_AABB_COLLIDER Indicates an AABB collider is attached to the static body. STATIC_BOX2D_COLLIDER Indicates a Box2D collider is attached to the static body. STATIC_CUSTOM_COLLIDER Indicates a custom collider is attached to the static body. STATIC_NONE Indicates no collider is attached to the static body."},{"location":"zeta/","title":"Zeta","text":"<p>This section covers the Zeta namespace. Zeta contains all the code related to the physics handler you'll use to simulate physics using Zeta2D. All the code inside this namespace can be found in physicshandler.h.</p>"},{"location":"zeta/#classes","title":"Classes","text":"<p>This subsection discusses the classes contained in Zeta. There's only a single class declared in the namespace and details on it are provided here.</p>"},{"location":"zeta/#handler","title":"Handler","text":"<p>This class will simulate physics for your program. In other words, for the rigid and static bodies you pass to this handler, collisions will be resolved and their physics attributes will be updated. You should store the pointers to the bodies in a list in your main program, too, so you can use them for graphical purposes. Below are the core fields, constructors, and functions.</p>"},{"location":"zeta/#fields","title":"Fields","text":"Type Identifier Description private struct rbs A struct storing the list of rigid bodies the engine will update. private struct sbs A struct storing the list of static bodies the engine will consider. private struct colWrapper A struct storing colliding rigid bodies and their collision manifolds. This is used for impulse resolution. private struct staticColWrapper A struct storing data about collisions between a rigid and static body. This is used for impulse resolution. private float updateStep The amount of time, in seconds, to perform a physics update after. Vec2D g The acceleration due to gravity as a vector."},{"location":"zeta/#constructor","title":"Constructor","text":"<p>Description: </p> <ul> <li>Create a physics handler with a specific gravity and update time step.  </li> </ul> <p>Parameters:</p> <ul> <li>g (Vec2D) - The acceleration due to gravity. Default of &lt;0, -9.8f&gt;.</li> <li>timeStep (float) - The amount of time, in seconds, to update physics after. Default of 0.0167f (equivalent to 60FPS).</li> </ul> <pre><code>Handler(ZMath::Vec2D const &amp;g = ZMath::Vec2D(0, -9.8f), float timeStep = FPS_60);\n</code></pre>"},{"location":"zeta/#functions","title":"Functions","text":"<p>Function Signature:</p> <pre><code>int update(float &amp;dt);\n</code></pre> <p>Description: </p> <ul> <li>Update the rigid bodies managed by this physics handler according to a dt value. The dt value passed in will be subtracted from by the handler. This returns an int equal to the number of times the physics was updated this update call. This way, the user can update anything that depends on the number of times the physics were updated properly. </li> </ul> <p>Parameters:</p> <ul> <li>dt (float) - The time ellapsed since the last time this was called. Dt should be added to in your main program instead of replaced for determinism purposes. Zeta2D will subtract from dt for you after each time it runs.</li> </ul> <p>Function Signature:</p> <pre><code>void addRigidBody(Primitives::RigidBody2D* rb);\n</code></pre> <p>Description: </p> <ul> <li>Add a rigid body to the handler. The rigid body is passed as a pointer so your graphics program can store and draw the rigid bodies, too, without any extra function calls.</li> </ul> <p>Parameters:</p> <ul> <li>rb (RigidBody2D*) - A pointer to the rigid body getting added to the handler.</li> </ul> <p>Function Signature:</p> <pre><code>void addRigidBodies(Primitives::RigidBody2D** rbs, int size);\n</code></pre> <p>Description: </p> <ul> <li>Add a list of rigid bodies to the handler. The rigid bodies are passed as a pointer so your graphics program can store and draw the rigid bodies, too, without any extra function calls.</li> </ul> <p>Parameters:</p> <ul> <li>rbs (RigidBody2D**) - An array of rigid body pointers to add to the handler.</li> <li>size (int) - The number of rigid bodies getting added to the handler.</li> </ul> <p>Function Signature:</p> <pre><code>bool removeRigidBody(Primitives::RigidBody2D* rb);\n</code></pre> <p>Description: </p> <ul> <li>Remove a rigid body from the handler based on its pointer. The data pointed to will be deleted by this function. A bool is returned indicating if the rigidbody was found and removed or not.</li> </ul> <p>Parameters:</p> <ul> <li>rb (RigidBody2D*) - A pointer to the rigid body getting removed from the handler.</li> </ul> <p>Function Signature:</p> <pre><code>void addStaticBody(Primitives::StaticBody2D* sb);\n</code></pre> <p>Description: </p> <ul> <li>Add a static body to the handler. The static body is passed as a pointer so your graphics program can store and draw the static bodies, too, without any extra function calls.</li> </ul> <p>Parameters:</p> <ul> <li>sb (StaticBody2D*) - A pointer to the static body getting added to the handler.</li> </ul> <p>Function Signature:</p> <pre><code>void addStaticBodies(Primitives::StaticBody2D** sbs, int size);\n</code></pre> <p>Description: </p> <ul> <li>Add a list of static bodies to the handler. The static bodies are passed as a pointer so your graphics program can store and draw the static bodies, too, without any extra function calls.</li> </ul> <p>Parameters:</p> <ul> <li>sbs (StaticBody2D**) - An array of static body pointers to add to the handler.</li> <li>size (int) - The number of static bodies getting added to the handler.</li> </ul> <p>Function Signature:</p> <pre><code>bool removeStaticBody(Primitives::StaticBody2D* sb);\n</code></pre> <p>Description: </p> <ul> <li>Remove a static body from the handler based on its pointer. The data pointed to will be deleted by this function. A bool is returned indicating if the staticbody was found and removed or not.</li> </ul> <p>Parameters:</p> <ul> <li>sb (StaticBody2D*) - A pointer to the static body getting removed from the handler.</li> </ul>"},{"location":"zeta/#functions_1","title":"Functions","text":"<p>This subsection touches on the functions available in the Zeta namespace. There are only two functions defined in this namespace and it is not recommended you call them in your main program. Details on them can still be found below on the offchance you need to use them.</p>"},{"location":"zeta/#handler_1","title":"Handler","text":"<p>Function Signature:</p> <pre><code>void applyImpulse(Primitives::RigidBody2D* rb1, Primitives::RigidBody2D* rb2, Collisions::CollisionManifold const &amp;manifold);\n</code></pre> <p>Description:</p> <ul> <li>Apply impulse to two colliding rigid bodies. The physics handler will run this function for you. It is not recommended for you to call this in your main program.</li> </ul> <p>Parameters:</p> <ul> <li>rb1 (RigidBody2D*) - A pointer to a colliding rigid body.</li> <li>rb2 (RigidBody2D*) - A pointer to the other colliding rigid body.</li> <li>manifold (CollisionManifold) - A struct containing the data about the collision.</li> </ul>"},{"location":"zeta/#handler_2","title":"Handler","text":"<p>Function Signature:</p> <pre><code>void applyImpulse(Primitives::RigidBody2D* rb, Primitives::StaticBody2D* sb, Collisions::CollisionManifold const &amp;manifold);\n</code></pre> <p>Description:</p> <ul> <li>Apply impulse to a rigid body colliding with a static body. The physics handler will run this function for you. It is not recommended for you to call this in your main program.</li> </ul> <p>Parameters:</p> <ul> <li>rb (RigidBody2D*) - A pointer to the colliding rigid body.</li> <li>sb (StaticBody2D*) - A pointer to the colliding static body.</li> <li>manifold (CollisionManifold) - A struct containing the data about the collision.</li> </ul>"},{"location":"zeta/#constants","title":"Constants","text":"<p>This subsection talks about useful constants declared in the physicshandler.h header. These constants are all related to common framerates to make it easier to set the handler to a chosen framerate. The intended use for all of them is to pass as the timeStep argument for the physics handler's constructor. The name of each indicates the physics framerate it will set the handler to.</p> Identifier Description FPS_24 Tells the handler to update 24 times per second. FPS_30 Tells the handler to update 30 times per second. FPS_40 Tells the handler to update 40 times per second. FPS_50 Tells the handler to update 50 times per second. FPS_60 Tells the handler to update 60 times per second."},{"location":"zmath/","title":"ZMath","text":"<p>This section covers the ZMath namespace. ZMath contains all of Zeta's custom math library's code and many helpful math functions. zmath2D.h contains all the code contained in the ZMath namespace.</p>"},{"location":"zmath/#classes","title":"Classes","text":"<p>This subsection touches on the classes found in the ZMath namespace. There are two classes used for Zeta's math library: Vec2D and Mat2D.</p>"},{"location":"zmath/#vec2d","title":"Vec2D","text":"<p>This class models a 2D vector. It's used extensibly throughout Zeta and will be how you pass information about positions, velocities forces, etc. to the physics engine. Any function described as being \"expensive\" is expensive in the computational sense. Below are the core functions and operators.</p>"},{"location":"zmath/#fields","title":"Fields","text":"Type Identifier Description int x The vector's x component. int y The vector's y component."},{"location":"zmath/#constructors","title":"Constructors","text":"<pre><code>Vec2D(float d = 0);      // Set both components to the same value. Default of 0.\nVec2D(float i, float j); // X is initialized to i and y to j.\nVec2D(Vec2D const &amp;vec); // Initialize the components to those of another vector.\n</code></pre>"},{"location":"zmath/#operators","title":"Operators","text":"<pre><code>Vec2D operator + (Vec2D const &amp;vec) const; // Add the vectors component-wise.\nVec2D operator + (float c) const;          // Add a float to both vector components.\nVec2D operator - (Vec2D const &amp;vec) const; // Subtract the vectors component-wise.\nVec2D operator * (float c) const;          // Multiply both components by a float.\nfloat operator * (Vec2D const &amp;vec) const; // Calculate the dot product of the two vectors.\nVec2D operator - () const;                 // Negate both components.\nbool operator == (Vec2D const &amp;vec) const; // Bool representing if the two vectors are equal.\nbool operator != (Vec2D const &amp;vec) const; // Bool representing if the two vectors are not equal.\nVec2D&amp; operator += (Vec2D const&amp; vec);     // Make this vector the sum of the vectors component-wise.\nVec2D&amp; operator += (float c);              // Modify this vector by adding a float to both components.\nVec2D&amp; operator -= (Vec2D const&amp; vec);     // Make this vector the difference of the vectors component-wise.\nVec2D&amp; operator *= (float c);              // Modify this vector by multiplying both components by a float.\n</code></pre>"},{"location":"zmath/#functions","title":"Functions","text":"<pre><code>void zero();                            // Set both components to 0.\nvoid set(float d);                      // Set both components to the same float.\nvoid set(float i, float j);             // Set x to i and y to j.\nvoid set(Vec2D const &amp;vec);             // Set the components to those of another vector.\nfloat cross(Vec2D const &amp;vec) const;    // Take the cross product of the two vectors.\nfloat mag() const;                      // Get the magnitude of the vector. This requires a sqrt.\nfloat magSq() const;                    // Get the magnitude squared of the vector.\nfloat dist(Vec2D const &amp;vec) const;     // Get the distance between two vectors. This requires a sqrt.\nfloat distSq(Vec2D const&amp; vec) const;   // Get the distance between two vectors squared.\nfloat getAngle(Vec2D const&amp; vec) const; // Get the angle between two vectors. This function is expensive.\nVec2D proj(Vec2D const &amp;vec) const;     // Take the vector projection of vec (parameter) onto this vector.\nVec2D normalize() const;                // Get the normalized vector in the same direction as this one.\nVec2D getSigns() const;                 // Get a vector with the signs of each component.\n</code></pre>"},{"location":"zmath/#mat2d","title":"Mat2D","text":"<p>This class models a 2x2 matrix. It's used primarily to store rotation matrices to rotate points in the physics engine. Any function described as being \"expensive\" is expensive in the computational sense. Below are the core functions and operators.</p>"},{"location":"zmath/#fields_1","title":"Fields","text":"Type Identifier Description Vec2D c1 The leftmost column vector of the matrix. Vec2D c2 The rightmost column vector of the matrix."},{"location":"zmath/#constructors_1","title":"Constructors","text":"<pre><code>// Initialize the matrix as follows:\n// |a11, a12|\n// |a21, a22|\nMat2D(float a11, float a12, float a21, float a22); // Check the above comment.\nMat2D();                                           // Initialize this matrix as the identity matrix.\nMat2D(Vec2D const &amp;col1, Vec2D const &amp;col2);       // Initialize c1 to col1 and c2 to col2.\nMat2D(Mat2D const &amp;mat);                           // Initialize the column vectors to those of another matrix.\n</code></pre>"},{"location":"zmath/#operators_1","title":"Operators","text":"<pre><code>Mat2D operator + (Mat2D const &amp;mat) const; // Add the matrices element-wise.\nMat2D operator + (float c) const;          // Add a float to each element of the matrix.\nMat2D operator - (Mat2D const &amp;mat) const; // Subtract the matrices element-wise.\nMat2D operator - (float c) const;          // Subtract a float from each element.\nMat2D operator * (Mat2D const &amp;mat) const; // Matrix multiplication of the two matrices.\nMat2D operator * (Vec2D const &amp;vec) const; // Matrix multiplication with vec treated as a 2x1 column vector.\nMat2D operator * (float c) const;          // Multiply each element by a float.\nMat2D operator - () const;                 // Negate each element.\nbool operator == (Mat2D const &amp;mat) const; // Bool representing if the matrices are equal.\nbool operator != (Mat2D const &amp;mat) const; // Bool representing if the matrices are not equal.\nMat2D&amp; operator += (Mat2D const &amp;mat);     // Make this matrix the sum of the matrices element-wise.\nMat2D&amp; operator += (float c);              // Modify this matrix by adding a float to each element.\nMat2D&amp; operator -= (Mat2D const &amp;mat);     // Make this matrix the difference of the matrices element-wise.\nMat2D&amp; operator -= (float c);              // Modify this matrix by subtracting a float from each element.\nMat2D&amp; operator *= (Mat2D const &amp;mat);     // Make this matrix the product from matrix multiplication.\nMat2D&amp; operator *= (float c);              // Modify this matrix by multiplying each element by a float.\n</code></pre>"},{"location":"zmath/#functions_1","title":"Functions","text":"<pre><code>// Set the matrix's elements as follows:\n// |a11, a12|\n// |a21, a22|\nvoid set(float a11, float a12, float a21, float a22); // Check the above comment.\nvoid set(Vec2D const &amp;col1, Vec2D const &amp;col2);       // Set c1 to col1 and c2 to col2.\nvoid set(Mat2D const &amp;mat);                           // Set the elements to those of another matrix.\nvoid zero();                                          // Set all elements to 0.\nMat2D inverse() const;                                // Get the inverse of this matrix.\nMat2D transpose() const;                              // Get the transpose of this matrix.\nMat2D getSigns() const;                               // Get the signs of each element of this matrix.\n// =====================\n// Static functions\n// =====================\nstatic Mat2D identity();               // Get the identity matrix.\nstatic Mat2D rotationMat(float theta); // Get the rotation matrix for an angle. Theta should be in degrees.\n</code></pre>"},{"location":"zmath/#functions_2","title":"Functions","text":"<p>This subsection highlights essential math functions used throughout the engine. Many of these are simple utility functions, making them convenient to use in your program. Below are all of the standalone functions provided in ZMath.</p>"},{"location":"zmath/#signof","title":"SIGNOF","text":"<p>Macro function to get the sign of a number. This returns -1 for a negative number and 1 for a positive number. 0 is treated as positive. The parameter can be any numeric data type. <pre><code>SIGNOF(num);\n</code></pre></p>"},{"location":"zmath/#toradians","title":"TORADIANS","text":"<p>Macro function to convert an angle in degrees to radians. This allows for storage of angles in degrees while still using cmath trig functions. The parameter can be any numeric data type and should be an angle in degrees. <pre><code>TORADIANS(degrees);\n</code></pre></p>"},{"location":"zmath/#min","title":"MIN","text":"<p>Macro function that returns the minimum of two numbers. The parameters can be any numeric data types. <pre><code>MIN(a, b);\n</code></pre></p>"},{"location":"zmath/#max","title":"MAX","text":"<p>Macro function that returns the maximum of two numbers. The parameters can be any numeric data types. <pre><code>MAX(a, b);\n</code></pre></p>"},{"location":"zmath/#abs","title":"abs","text":"<p>Function returning the absolute value of a vector component-wise. <pre><code>Vec2D abs(Vec2D const &amp;vec);\n</code></pre></p> <p>Function returning the absolute value of a matrix element-wise. <pre><code>Mat2D abs(Mat2D const &amp;mat);\n</code></pre></p>"},{"location":"zmath/#rotate","title":"rotate","text":"<p>Function that rotates a point in 2D space about an origin. The point's components will be updated directly. The angle to rotate by should be in degrees. <pre><code>void rotate(Vec2D &amp;point, Vec2D const &amp;origin, float angle);\n</code></pre></p>"},{"location":"zmath/#compare","title":"compare","text":"<p>Function that returns if a float is close enough to another float to be considered approximately the same. This should be used to handle tolerance for floating point values. Epsilon is the tolerance value and is 5 * 10^-4 by default. <pre><code>bool compare(float a, float b, float epsilon = EPSILON);\n</code></pre></p> <p>Function that returns if a Vec2D is close enough to another Vec2D to be considered approximately the same. This should be used to handle tolerance for vectors of floats. Epsilon is the tolerance value and is 5 * 10^-4 by default. <pre><code>bool compare(Vec2D const &amp;u, Vec2D const &amp;v, float epsilon = EPSILON);\n</code></pre></p>"},{"location":"zmath/#clamp","title":"clamp","text":"<p>Function that returns a float clamped between a min and max. If the float is greater than max, this will return max; if the float is less than min, this will return min; otherwise, the float will be returned. <pre><code>float clamp(float n, float min, float max);\n</code></pre></p> <p>Function that returns a Vec2D clamped component-wise between a min vector and a max vector. The process described for single float clamping is applied to each element of the Vec2D in this function. <pre><code>Vec2D clamp(Vec2D const &amp;n, Vec2D const &amp;min, Vec2D const &amp;max);\n</code></pre></p>"},{"location":"zmath/#constants","title":"Constants","text":"<p>ZMath offers 2 constants defined through preprocessor directives for ease of use: \u03c0 and \u03b5.</p>"},{"location":"zmath/#pi","title":"PI","text":"<p>Constant representing \u03c0. This is set to 3.1415926535897932.</p>"},{"location":"zmath/#epsilon","title":"EPSILON","text":"<p>Constant representing the default tolerance value. This is set to 0.0005 (5 * 10^-4).</p>"}]}